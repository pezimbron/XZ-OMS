import { NextRequest, NextResponse } from 'next/server'
import { getPayload } from 'payload'
import config from '@payload-config'

interface VendorInvoice {
  id: string
  jobId: string
  jobNumber: string
  jobTitle: string
  vendor: {
    id: string
    name: string
  } | null
  description: string
  supplier: string
  amount: number
  paymentStatus: string
  paidDate?: string
  notes?: string
  quickbooksId?: string
  quickbooksDocNumber?: string
  quickbooksSyncedAt?: string
  autoGenerated?: boolean
  createdAt: string
}

interface StatsResult {
  totalInvoices: number
  totalAmount: number
  paidAmount: number
  unpaidAmount: number
  pendingAmount: number
  byStatus: {
    paid: { count: number; amount: number }
    unpaid: { count: number; amount: number }
    pending: { count: number; amount: number }
  }
  withQuickBooks: number
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)

    // Query parameters
    const vendorId = searchParams.get('vendorId')
    const paymentStatus = searchParams.get('paymentStatus')
    const dateFrom = searchParams.get('dateFrom')
    const dateTo = searchParams.get('dateTo')
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '25')

    const payload = await getPayload({ config })

    // Fetch jobs with minimal depth
    const jobs = await payload.find({
      collection: 'jobs',
      depth: 1, // Reduced from 2 - less nested data
      limit: 500,
      overrideAccess: true,
    })

    // Get vendors list
    const vendorsResponse = await payload.find({
      collection: 'vendors',
      limit: 200,
      depth: 0,
      overrideAccess: true,
    })
    const vendorsMap = new Map(
      vendorsResponse.docs.map((v: any) => [v.id, { id: v.id, name: v.companyName }])
    )

    // Flatten all external expenses into vendor invoices
    const allInvoices: VendorInvoice[] = []

    for (const job of jobs.docs) {
      const jobData = job as any
      const expenses = jobData.externalExpenses || []

      for (const expense of expenses) {
        // Skip auto-generated expenses (from product defaults) - these are internal
        // cost estimates, not actual vendor invoices
        if (expense.autoGenerated) continue

        // Get vendor from job's subcontractorVendor or tech's vendor
        let vendorInfo: { id: string; name: string } | null = null

        if (jobData.subcontractorVendor) {
          const subVendorId = typeof jobData.subcontractorVendor === 'object'
            ? jobData.subcontractorVendor.id
            : jobData.subcontractorVendor
          vendorInfo = vendorsMap.get(subVendorId) || null
          if (!vendorInfo && typeof jobData.subcontractorVendor === 'object') {
            vendorInfo = { id: subVendorId, name: jobData.subcontractorVendor.companyName }
          }
        } else if (jobData.tech?.vendor) {
          const techVendorId = typeof jobData.tech.vendor === 'object'
            ? jobData.tech.vendor.id
            : jobData.tech.vendor
          vendorInfo = vendorsMap.get(techVendorId) || null
          if (!vendorInfo && typeof jobData.tech.vendor === 'object') {
            vendorInfo = { id: techVendorId, name: jobData.tech.vendor.companyName }
          }
        }

        // If no vendor from job, try supplier name
        if (!vendorInfo && expense.supplier) {
          vendorInfo = { id: 'external', name: expense.supplier }
        }

        const invoice: VendorInvoice = {
          id: expense.id || `${jobData.id}-${expenses.indexOf(expense)}`,
          jobId: jobData.id,
          jobNumber: jobData.jobNumber || `#${String(jobData.id).slice(0, 8)}`,
          jobTitle: jobData.title || jobData.address || 'Untitled Job',
          vendor: vendorInfo,
          description: expense.description || '',
          supplier: expense.supplier || '',
          amount: expense.amount || 0,
          paymentStatus: expense.paymentStatus || 'unpaid',
          paidDate: expense.paidDate,
          notes: expense.notes,
          quickbooksId: expense.quickbooksId,
          quickbooksDocNumber: expense.quickbooksDocNumber,
          quickbooksSyncedAt: expense.quickbooksSyncedAt,
          autoGenerated: expense.autoGenerated,
          createdAt: jobData.createdAt,
        }

        allInvoices.push(invoice)
      }
    }

    // Apply filters
    let filteredInvoices = allInvoices

    // Filter by vendor
    if (vendorId && vendorId !== 'all') {
      filteredInvoices = filteredInvoices.filter(inv => inv.vendor?.id === vendorId)
    }

    // Filter by payment status
    if (paymentStatus && paymentStatus !== 'all') {
      filteredInvoices = filteredInvoices.filter(inv => inv.paymentStatus === paymentStatus)
    }

    // Filter by date range (using job createdAt)
    if (dateFrom) {
      const fromDate = new Date(dateFrom)
      filteredInvoices = filteredInvoices.filter(inv => new Date(inv.createdAt) >= fromDate)
    }
    if (dateTo) {
      const toDate = new Date(dateTo)
      toDate.setHours(23, 59, 59, 999)
      filteredInvoices = filteredInvoices.filter(inv => new Date(inv.createdAt) <= toDate)
    }

    // Sort by date descending (newest first)
    filteredInvoices.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())

    // Calculate stats before pagination
    const stats: StatsResult = {
      totalInvoices: filteredInvoices.length,
      totalAmount: filteredInvoices.reduce((sum, inv) => sum + inv.amount, 0),
      paidAmount: filteredInvoices
        .filter(inv => inv.paymentStatus === 'paid')
        .reduce((sum, inv) => sum + inv.amount, 0),
      unpaidAmount: filteredInvoices
        .filter(inv => inv.paymentStatus === 'unpaid')
        .reduce((sum, inv) => sum + inv.amount, 0),
      pendingAmount: filteredInvoices
        .filter(inv => inv.paymentStatus === 'pending')
        .reduce((sum, inv) => sum + inv.amount, 0),
      byStatus: {
        paid: {
          count: filteredInvoices.filter(inv => inv.paymentStatus === 'paid').length,
          amount: filteredInvoices
            .filter(inv => inv.paymentStatus === 'paid')
            .reduce((sum, inv) => sum + inv.amount, 0),
        },
        unpaid: {
          count: filteredInvoices.filter(inv => inv.paymentStatus === 'unpaid').length,
          amount: filteredInvoices
            .filter(inv => inv.paymentStatus === 'unpaid')
            .reduce((sum, inv) => sum + inv.amount, 0),
        },
        pending: {
          count: filteredInvoices.filter(inv => inv.paymentStatus === 'pending').length,
          amount: filteredInvoices
            .filter(inv => inv.paymentStatus === 'pending')
            .reduce((sum, inv) => sum + inv.amount, 0),
        },
      },
      withQuickBooks: filteredInvoices.filter(inv => inv.quickbooksId).length,
    }

    // Apply pagination
    const totalItems = filteredInvoices.length
    const totalPages = Math.ceil(totalItems / limit)
    const offset = (page - 1) * limit
    const paginatedInvoices = filteredInvoices.slice(offset, offset + limit)

    // Get unique vendors for filter dropdown
    const uniqueVendors = Array.from(
      new Map(
        allInvoices
          .filter(inv => inv.vendor)
          .map(inv => [inv.vendor!.id, inv.vendor!])
      ).values()
    ).sort((a, b) => a.name.localeCompare(b.name))

    return NextResponse.json({
      success: true,
      invoices: paginatedInvoices,
      stats,
      pagination: {
        page,
        limit,
        totalItems,
        totalPages,
      },
      vendors: uniqueVendors,
    })
  } catch (error: any) {
    console.error('Error fetching vendor invoices:', error)
    return NextResponse.json(
      { error: 'Failed to fetch vendor invoices', details: error.message },
      { status: 500 }
    )
  }
}
