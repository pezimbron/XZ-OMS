import type { CollectionBeforeChangeHook } from 'payload'

export const autoGenerateExpenses: CollectionBeforeChangeHook = async ({
  data,
  req,
  operation,
  originalDoc,
}) => {
  // Only run on update operations
  if (operation !== 'update') {
    return data
  }

  const payload = req.payload

  try {
    // Get current and previous line items
    const currentLineItems = data.lineItems || []
    const previousLineItems = originalDoc?.lineItems || []

    // Find newly added products by comparing IDs
    const previousProductIds = new Set(
      previousLineItems.map((item: any) => 
        typeof item.product === 'object' ? item.product?.id : item.product
      ).filter(Boolean)
    )

    const newProducts = currentLineItems.filter((item: any) => {
      const productId = typeof item.product === 'object' ? item.product?.id : item.product
      return productId && !previousProductIds.has(productId)
    })

    if (newProducts.length === 0) {
      return data
    }

    // Fetch product details for new products
    const newProductIds = newProducts.map((item: any) => 
      typeof item.product === 'object' ? item.product?.id : item.product
    ).filter(Boolean)

    const productsData = await payload.find({
      collection: 'products',
      where: {
        id: {
          in: newProductIds,
        },
      },
      limit: 100,
    })

    // Filter products that have auto-expense enabled
    const productsWithExpenses = productsData.docs.filter(
      (product: any) => product.hasDefaultExpense === true
    )

    if (productsWithExpenses.length === 0) {
      return data
    }

    // Get existing external expenses
    const existingExpenses = data.externalExpenses || []

    // Create new expense entries for products with auto-expense
    const newExpenses = productsWithExpenses.map((product: any) => ({
      description: product.expenseDescription || `${product.name} - External Service`,
      supplier: '',
      contactInfo: '',
      amount: product.defaultExpenseCost || 0,
      paymentStatus: 'unpaid',
      paidDate: null,
      notes: `Auto-generated from product: ${product.name}`,
      autoGenerated: true,
    }))

    // Combine existing and new expenses
    const updatedExpenses = [...existingExpenses, ...newExpenses]

    console.log(`[Auto-Expense] Generated ${newExpenses.length} expense(s) for job ${data.jobId}`)

    // Modify data directly and return it - this will be saved to the database
    data.externalExpenses = updatedExpenses

    return data
  } catch (error) {
    console.error('[Auto-Expense] Error generating expenses:', error)
    // Return original data if there's an error to prevent blocking the update
    return data
  }
}
